#!/bin/bash
#
#  A simple command-line wrapper for Apple's iTunes.
#
#  Install or symlink into your path and "itunes -h" or "itunes help" for help.
#
#  Copyright 2012 Sam Graham.  http://www.illusori.co.uk/
#  This work is licensed under a
#  Creative Commons Attribution-Share Alike 2.0 UK: England & Wales License
#  http://creativecommons.org/licenses/by-sa/2.0/uk/
#  In human-readble terms: you're free to copy, distribute and modify
#  providing you maintain attribution and licence.
#
#  Use at your own risk, no fitness for purpose implied, etc, etc.

version='1.0.4'
progname=`basename $0`

#  Version and help.

function _cmd_version() {
    echo "$progname version $version"
}

function _cmd_help() {
    _cmd_version
    echo "Usage: $progname [-v] [-h] [-d] <command> [<args>]

Switches:
    -v          Show version information and exit.
    -h          Show this help and exit.
    -d          Enable debug messages, additional -d options increase verbosity.

Navigation commands:
    play        Start or resume playing.
    pause       Pause playing.
    stop        Stop playing.
    next        Skip to next track.
    prev        Skip back to previous track.
    info        View info about current track.
    shuffle     View or set shuffle status.
    repeat      View or set repeat status.
    playlist    View or choose playlist.
    playlists   List all playlists.

Volume commands:
    vol[ume]    View or adjust iTunes volume 'up', 'down' or percentage.
    mute        Mutes iTunes.
    unmute      Unmutes iTunes, restoring previous volume level.
    sysvol[ume] View or adjust system volume 'up', 'down' or percentage.
    sysmute     Mute system sound.
    sysunmute   Unmute system sound.

Application commands:
    open        Start iTunes running.
    quit        Quit iTunes.
    show        Hide the iTunes window.
    hide        Show the iTunes window.

Additional commands:
    version     Show version information and exit.
    help        Show this help and exit."
}

function _cmd_unknown() {
    echo "Unknown command '$cmd', try '$progname help' for a list of valid commands."
}

#  Helper functions

function _err() {
    echo "$*" 1>&2
}

function _log() {
    if [ "$debug" -ge "$1" ]; then
        shift;
        _err "$*"
    fi
}

function _pluralize() {
    if [ "$1" = "1" ]; then
        echo "$1 $2"
    else
        if [ -n "$3" ]; then
            echo "$1 $3"
        else
            echo "$1 ${2}s"
        fi
    fi
}

function _osascript() {
    _log 2 "Run: osascript -e \"$*\""
    if [ "$debug" -gt 0 ]; then
        osascript -e "$*"
    else
        osascript -e "$*" 2>&-
    fi
}

function _tell_itunes() {
    _osascript "tell application \"iTunes\" to $*"
}

#  Fetch from iTunes from the data-structures in $1 into the array
#  variables constructed from prefix $2 and column names $3+ the
#  given columns in the data-structure.
#  If that's clear.
#  No?
#  Anyone?
function _fetch_from_itunes() {
    local source="$1"
    local use_loop=0
    if [ "$source" = "LOOP" ]; then
        use_loop=1
        source="$2"
        shift
    fi
    local prefix="$2"
    shift 2
    #  Yet more hacks, this allows multi-word AppleScript properties
    #  such as "database id" to end up in "database_id".
    #  You can also do this by messing with $IFS and ${var//search/replace}
    #  but, although I got it working, I had a brief outbreak of sanity and
    #  chose this instead...
    local columns=''
    local script_columns=''
    for column in "$@"; do
        columns="${columns} ${column// /_}"
        script_columns="${script_columns}, ${column}"
    done
    columns="${columns:1}"
    script_columns="${script_columns:2}"

    _log 4 "source '$structure', prefix '$prefix', columns '$columns', script_columns '$script_columns'"

    #  Best if we don't loop within AppleScript, it can be painfully slow
    #  for large arrays, but on the other hand, for columns that are
    #  actually expressions rather than properties, we appear to have to loop.
    if [ "$use_loop" = 0 ]; then
        local result=$(_osascript "tell application \"iTunes\" to set ret to ($script_columns) of $source
set old_delim to AppleScript's text item delimiters
set AppleScript's text item delimiters to \"\\n\"
set ret to ret as text
set AppleScript's text item delimiters to old_delim
ret")
    else
        local result=$(_osascript "tell application \"iTunes\"
    set ret to {}
    repeat with v in $source
        copy ($script_columns) of v to the end of ret
    end repeat
end tell
set old_delim to AppleScript's text item delimiters
set AppleScript's text item delimiters to \"\\n\"
set ret to ret as text
set AppleScript's text item delimiters to old_delim
ret")
    fi
    _log 4 "result '$result'"

    _read_rows_from_value_lines_grouped_by_column "$prefix" "$result" $columns
}

#  Low-level row/rowset fetching/clearing. This stuff is nasty.

#  This function is lifted from my bash-snippets repo on GitHub,
#  gawp in horror at its unspeakable glory.
function _read_rows_from_value_lines_grouped_by_column() {
    local prefix="$1"
    local content="$2"
    shift 2
    local columns
    read -r -a columns <<< "$*"

    local row_count=$(($(wc -l <<< "$content") / ${#columns[*]}))

    for column in "${columns[@]}"; do
        unset "${prefix}_${column}"
    done

    local row_idx=0
    local column_idx=0
    local value
    while read value; do
        column=${columns[column_idx]}
        #  Ho hum, I gave up and used eval, couldn't get this working with $(())
        printf -v value "%q" "$value"
        eval "${prefix}_${column}[${row_idx}]=$value"

        row_idx=$((row_idx + 1))
        if [ "$row_idx" -ge "$row_count" ]; then
            row_idx=0
            column_idx=$((column_idx + 1))
        fi
        #_log 5 "Column is $column, column_idx now $column_idx, row_idx now $row_idx, value $value"
    done <<< "$content"
}

function _scrub_rows() {
    local prefix="$1"
    shift
    local columns="$@"

    for column in $columns; do
        local full_column="${prefix}_${column}"
        _log 6 "Scrubbing \$$full_column"
        unset $full_column
    done
}

#  Schema stuff.

_track_columns="name artist album year rating time id"
_playlist_columns="name time id"

#  Fetchers/scrubbers for the objects in the schema.

function _fetch_tracks() {
    local source="$1"
    local prefix="$2"
    _fetch_from_itunes "$source" "$prefix" $_track_columns
}
function _scrub_tracks() {
    local prefix="$1"
    _scrub_rows "$prefix" $_track_columns
}

function _fetch_playlists() {
    local source="$1"
    local prefix="$2"
    _fetch_from_itunes "$source" "$prefix" $_playlist_columns
    _fetch_from_itunes LOOP "$source" "$prefix" "count tracks"
}
function _scrub_playlists() {
    local prefix="$1"
    _scrub_rows "$prefix" $_playlist_columns
}

#  Fetchers/scrubbers for specific global objects.

function _fetch_current_track() {
    if [ -z "$current_track_name" ]; then
        _fetch_tracks "current track" current_track
    fi
    if [ -z "$current_track_pos" ]; then
        current_track_pos=$(_tell_itunes "player position as integer")
        local min=$((current_track_pos / 60))
        local sec=$(printf "%02d" $((current_track_pos % 60)))
        current_track_pos="${min}:${sec}"
        _log 3 "Fetched trackpos '$current_track_pos'"
    fi
}
function _scrub_current_track() {
    _scrub_tracks "current_track"
}

function _fetch_current_playlist() {
    if [ -z "$current_playlist_name" ]; then
        _fetch_playlists "current playlist" current_playlist
    fi
}
function _scrub_current_playlist() {
    _scrub_playlists "current_playlist"
}


#  Views.

function _show_track() {
    local row_prefix="$1"
    local row_idx="${2:-0}"
    local brief="${3:-0}"
    local preamble="$4"

    #  Ho ho.
    eval "local name=\${${row_prefix}_name[row_idx]}"
    eval "local artist=\${${row_prefix}_artist[row_idx]}"
    eval "local album=\${${row_prefix}_album[row_idx]}"
    eval "local year=\${${row_prefix}_year[row_idx]}"
    eval "local rating=\${${row_prefix}_rating[row_idx]}"
    eval "local time=\${${row_prefix}_time[row_idx]}"
    eval "local id=\${${row_prefix}_id[row_idx]}"

    if [ -n "$preamble" ]; then
        preamble="$preamble "
    fi

    echo -n "$preamble\"$name\""
    if [ -n "$artist" ]; then
        echo -n " by $artist"
    fi
    if [ -n "$album" ]; then
        echo -n ", from \"$album\""
        if [ -n "$year" -a "$year" != 0 ]; then
            echo -n " ($year)"
        fi
    fi
    if [ -n "$current_track_id" -a -n "$current_track_pos" -a "$current_track_id" = "$id" ]; then
        echo " ($current_track_pos of $time)"
    else
        echo " ($time)"
    fi
    if [ "$brief" = 0 -a -n "$rating" -a "$rating" != 0 ]; then
        echo "You've rated this track $rating."
    fi

}

function _show_current_track() {
    local preamble="$1"
    local brief="${2:-0}"

    _fetch_current_track
    _show_track current_track 0 $brief "$preamble"
}

function _show_playlist() {
    local row_prefix="$1"
    local row_idx="${2:-0}"
    local brief="${3:-0}"
    local preamble="$4"

    #  Ho ho.
    eval "local name=\${${row_prefix}_name[row_idx]}"
    eval "local time=\${${row_prefix}_time[row_idx]}"
    eval "local id=\${${row_prefix}_id[row_idx]}"
    eval "local count_tracks=\${${row_prefix}_count_tracks[row_idx]}"

    if [ -n "$preamble" ]; then
        preamble="$preamble "
    fi

    echo -n "$preamble\"${name}\" (${time}) ("
    echo -n $(_pluralize "${count_tracks}" 'track')
    echo -n ")"
    if [ "$brief" = 0 ]; then
        local track_prefix="${row_prefix}_tracks"
        local track_idx=0
        eval "local track_name=\${${track_prefix}_name[track_idx]}"
        eval "local track_id=\${${track_prefix}_id[track_idx]}"
        while [ -n "$track_name" ]; do
            if [ "$current_track_id" = "$track_id" ]; then
                echo -n "* "
            else
                echo -n "  "
            fi
            _show_track $track_prefix $track_idx 1
            track_idx=$((track_idx + 1))
            eval "track_name=\${${track_prefix}_name[track_idx]}"
            eval "track_id=\${${track_prefix}_id[track_idx]}"
        done
    else
        echo
    fi
}

#  Navigation commands: play, pause, stop, next, prev, playlist

function _cmd_play() {
    _tell_itunes "play"
    _scrub_current_track
    _show_current_track "Resuming" 1
}

function _cmd_pause() {
    echo "Pausing iTunes."
    _tell_itunes "pause"
}

function _cmd_stop() {
    echo "Stopping iTunes."
    _tell_itunes "stop"
}

function _cmd_next() {
    _tell_itunes "next track"
    _scrub_current_track
    _show_current_track "Skipping to next track," 1
}

function _cmd_prev() {
    _tell_itunes "previous track"
    _scrub_current_track
    _show_current_track "Skipping to previous track," 1
}

function _cmd_info() {
    _show_current_track "Currently playing"
}

function _cmd_shuffle() {
    if [ -z "$1" ]; then
        curshuffle=$(_tell_itunes "shuffle of current playlist")
        _log 3 "Fetched shuffle is '$curshuffle'"
        if [ "$curshuffle" = "true" ]; then
            echo "Current shuffle setting is on."
        else
            echo "Current shuffle setting is off."
        fi
    else
        case "$1" in
            "on")
                echo "Switching shuffle on."
                _tell_itunes "set shuffle of current playlist to true"
                ;;
            "off")
                echo "Switching shuffle off."
                _tell_itunes "set shuffle of current playlist to false"
                ;;
            *)
                _err "Shuffle must be one of 'on' or 'off'."
                ;;
        esac
    fi
}

function _cmd_repeat() {
    if [ -z "$1" ]; then
        currepeat=$(_tell_itunes "song repeat of current playlist")
        _log 3 "Fetched repeat is '$currepeat'"
        echo "Current repeat setting is $currepeat."
    else
        case "$1" in
            "off" | "one" | "all")
                echo "Switching repeat to $1."
                _tell_itunes "set song repeat of current playlist to $1"
                ;;
            *)
                _err "Repeat must be one of 'one', 'all' or 'off'."
                ;;
        esac
    fi
}

function _cmd_playlist() {
    if [ -z "$1" ]; then
        _fetch_current_track
        _fetch_current_playlist
        _fetch_tracks "every track of current playlist" current_playlist_tracks

        _show_playlist current_playlist 0 0 "Currently listening to playlist"
    else
        _tell_itunes "play playlist \"$*\""
        _scrub_current_track
        _scrub_current_playlist
        _fetch_current_playlist
        _show_current_track "Now listening to playlist \"${current_playlist_name}\" (${current_playlist_time}), playing" 1
    fi
}

function _cmd_playlists() {
    _fetch_playlists "playlists" playlist
    echo "Playlists"
    local playlist_idx=0
    while [ -n "${playlist_name[playlist_idx]}" ]; do
        _show_playlist playlist $playlist_idx 1 " "
        playlist_idx=$((playlist_idx + 1))
    done
}

#  Volume commands: volume, mute, unmute

function _cmd_volume() {
    curvol=$(_tell_itunes "sound volume as integer")
    _log 3 "Fetched volume is '$curvol'"
    if [ -z "$1" ]; then
        echo "Current iTunes volume is $curvol%"
    else
        newvol=-1
        case "$1" in
            "up")     newvol=$(($curvol + 10)) ;;
            "down")   newvol=$(($curvol - 10)) ;;
            "mute")   _cmd_mute                ;;
            "unmute") _cmd_unmute              ;;
            *)
                if [ "$1" -ge 0 -a "$1" -le 100 2>&- ] ; then
                    newvol=$1
                else
                    _err "Volume must be one of 'up', 'down', 'mute', 'unmute' or an integer between 0 and 100."
                fi
                ;;
        esac
        if [ $newvol != -1 ]; then
            echo "Changing iTunes volume level from $curvol to $newvol%"
            _tell_itunes "set sound volume to $newvol"
        fi
    fi
}

function _cmd_mute() {
    echo "Muting iTunes."
    _tell_itunes "set mute to true"
}

function _cmd_unmute() {
    echo "Unmuting iTunes."
    _tell_itunes "set mute to false"
}

#  Not strictly iTunes, but likely to be useful anyway.
function _cmd_sysvolume() {
    curvol=$(_osascript "output volume of (get volume settings)")
    _log 3 "Fetched volume is '$curvol'"
    if [ -z "$1" ]; then
        echo "Current system volume is $curvol%"
    else
        newvol=-1
        case "$1" in
            "up")     newvol=$(($curvol + 10)) ;;
            "down")   newvol=$(($curvol - 10)) ;;
            "mute")   _cmd_sysmute             ;;
            "unmute") _cmd_sysunmute           ;;
            *)
                if [ "$1" -ge 0 -a "$1" -le 100 2>&- ] ; then
                    newvol=$1
                else
                    _err "Volume must be one of 'up', 'down', 'mute', 'unmute' or an integer between 0 and 100."
                fi
                ;;
        esac
        if [ $newvol != -1 ]; then
            echo "Changing system volume level from $curvol to $newvol%"
            _osascript "set volume output volume $newvol"
        fi
    fi
}

function _cmd_sysmute() {
    echo "Muting system sound."
    _osascript "set volume output muted true"
}

function _cmd_sysunmute() {
    echo "Unmuting system sound."
    _osascript "set volume output muted false"
}

#  Application commands: open, quit

function _cmd_open() {
    echo "Opening iTunes."
    open -a iTunes
}

function _cmd_quit() {
    echo "Quitting iTunes."
    _tell_itunes "quit"
}

function _cmd_show() {
    echo "Showing iTunes window."
    _osascript "tell application \"System Events\" to set visible of process \"iTunes\" to true"
}

function _cmd_hide() {
    echo "Hiding iTunes window."
    _osascript "tell application \"System Events\" to set visible of process \"iTunes\" to false"
}

#  Argument processing and dispatch

debug=0
while getopts "hvd" "OPTNAME";
do
    case $OPTNAME in
        h) _cmd_help;    exit 0  ;;
        v) _cmd_version; exit 0  ;;
        d) debug=$(($debug + 1)) ;;
        *) exit -1               ;;
    esac
done
shift $(($OPTIND - 1))

cmd=$1
shift
case "$cmd" in
    #  Navigation commands.
    play|resume|unpause)
                 _cmd_play "$@"      ;;
    pause)       _cmd_pause "$@"     ;;
    stop)        _cmd_stop "$@"      ;;
    next)        _cmd_next "$@"      ;;
    prev)        _cmd_prev "$@"      ;;
    info)        _cmd_info "$@"      ;;
    shuffle)     _cmd_shuffle "$@"   ;;
    repeat)      _cmd_repeat "$@"    ;;
    playlist)    _cmd_playlist "$@"  ;;
    playlists)   _cmd_playlists "$@" ;;
    #  Volume commands.
    vol|volume)  _cmd_volume "$@"    ;;
    mute)        _cmd_mute "$@"      ;;
    unmute)      _cmd_unmute "$@"    ;;
    sysvol|sysvolume)
                 _cmd_sysvolume "$@" ;;
    sysmute)     _cmd_sysmute "$@"   ;;
    sysunmute)   _cmd_sysunmute "$@" ;;
    #  Application commands.
    open)        _cmd_open "$@"      ;;
    quit)        _cmd_quit "$@"      ;;
    show|reveal) _cmd_show "$@"      ;;
    hide)        _cmd_hide "$@"      ;;
    #  Extra commands.
    version)     _cmd_version "$@"   ;;
    ""|help)     _cmd_help "$@"      ;;
    *)           _cmd_unknown "$@"   ;;
esac
